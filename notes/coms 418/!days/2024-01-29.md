#coms418 

### overlay of subdivisions
- The overlay problem
	- overlay of two DCEL result in new planar subdivision.
	- General approach
		- Copy the DCEL of the two subdivisions
		- Transform the result into a valid DCEL for the subdivision overlay
			- Computer the intersections of edges from different subdivision
			- link together appropriate parts of the two DCEL
				- vertex and half-edge records
				- face records
		- use modified plane sweep :(
	- [[Invariant]]
	- At an event point
		- update the event queue and sweep-line status tree as in the segment intersection algorithm.
		- in case the event point is:
			- Vertex adjacent to edges from one subdivision
				- no additional work!
			- Intersection of edges from different subdivisions
				- Link the DCEL1 and DCEL2 at the intersection point.
					- handle all possible cases.
	- Three types of edge crossing
		- [[Vertex-Vertex]]: two vertices from different subdivisions coincide with each other
		- [[Vertex-Edge]]: an edge from one input subdivision passes through a vertex of another subdivision.
		- [[Edge-Edge]]: two edges from different subdivision intersect in their interior.
	- Vertex-Edge Update:
		- 1. Edge $e$ splits into two edges $e'$ and $e''$ at intersection $v$
		- 2. shorten half edge $e_a = (u,w)$ to $e_a' = (u,v)$
		- 3. shorten half edge $e_b = (w,u)$ to $e_b'' = (w,v)$
		- 4. create their twin half edges with $v$ as the origin. Update twin pointers
		- 5. Each of the four new half edges requires four pointer updates
			- its own next and prev pointers
			- the next pointer of its predecessor
			- the prev pointer of it successor
			- pointer inheritances
				- $Next(e'_b) \leftarrow Next(e_b)$
				- $Next(e''_b)\leftarrow Next(e_a)$
				- $Prev(Next(e_b)) \leftarrow e'_b$
				- $Prev(Next(e_a)) \leftarrow e''_b$
				- $Prev(e'_a)\leftarrow Prev(e_a)$
				- $Prev(e''_a)\leftarrow Prev(e_b)$
				- $Next(Prev(e_a)) \leftarrow e'_a$
				- $Next(Prev(e_b)) \leftarrow e''_a$
			- extra effort
				- $Next(Prev(e'_b)) \leftarrow e'_b$
				- $Next(Prev(e''_b)) \leftarrow e''_b$
				- $Prev(next(e'_a)) \leftarrow e'_a$
				- $Prev(Next(e''_a)) \leftarrow e''_a$
				- $Next(e''_a)=?$
					- next face on edge bound
	- [[Overlay Algorithm]] -yikes
### art gallery
- basically just use the three color thing. its easy